<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>pyRTX.analysis_utils API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyRTX.analysis_utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Utilities for data/output analysis
import numpy as np
from scipy import interpolate
import spiceypy as sp
from PIL import Image
from pyRTX.utils_rt import block_normalize
from numba import jit
from numpy import ceil

&#34;&#34;&#34;
A set of utilities mainly focused on result analysis and data manipulation
&#34;&#34;&#34;






class LookupTable():
        &#34;&#34;&#34;
        This class is used to store results in the shape aof a lookup table.
        This is mainly used to store the resultas of a set of raytracing results
        example: the solar pressure for a body is computed for a grid of RA/DEC values.
        these values can be stored in the LookupTable object and later retrieved.
        This class offers the possibility of not oly retrieving pre-computed values, but
        aslso interpolating between grid points.

        NOTE: the grid of the lookup table does not need to be regular
        the interpolation is based on numpy griddata method which is able to cope
        with unstructured grids

        The main way of retrieving values is through indexing. The following are implemented:

        LUT[a,b]: if a, b are in the original lookup table, the original values are returned, otherwise they are interpolated
        LUT[:,:] or LUT[a:b, c:d]: return the original lut sliced as requested
        LUT[:,a]: return the original lut (all elements of first axis, integer-indexed elements of second axis)
        LUT[array-like, array-like]: return the lookup table interpolated in the array-like points



        Parameters
        ----------
        linspace_x : np.array(N,)
                The x axis of the lookup table
        linspace_y : np.array(M,)
                The y axis of the lookup table
        values : np.ndarray (N,M,1)
                The lookup table values


        &#34;&#34;&#34;
        def __init__(self, linspace_x, linspace_y, values):
                self.linspace_x = linspace_x
                self.linspace_y = linspace_y
                self.values = values

                self._set_defaults()


        def _set_defaults(self):
                self.interpType = &#39;cubic&#39;

        def _interpolator(self, x, y):

                x, y = np.meshgrid(x,y)
                meshgrid_x, meshgrid_y = np.meshgrid(self.linspace_x, self.linspace_y)
                #return  interpolate.griddata((meshgrid_x.ravel(), meshgrid_y.ravel()), self.values.T.ravel(),np.array([x,y]).T, method = self.interpType)
                return  interpolate.griddata((meshgrid_x.ravel(), meshgrid_y.ravel()), self.values.T.ravel(),(x,y), method = self.interpType)

        def set_interpType(self, interpType):
                self.interpType = interpType


        def _get_idx(self, ind, search_list):
                return np.where(search_list == ind)[0][0]

        
        def interp_point(self, x, y):
                return self._interpolator(x,y)


        def __getitem__(self, idxs):
                &#34;&#34;&#34;
                Implement a getitem method.
                Several usages are possible:

                LUT[a,b]: if a, b are in the original lookup table, the original values are returned, otherwise they are interpolated
                LUT[:,:] or LUT[a:b, c:d]: return the original lut sliced as requested
                LUT[:,a]: return the original lut (all elements of first axis, integer-indexed elements of second axis)
                LUT[array-like, array-like]: return the lookup table interpolated in the array-like points

                &#34;&#34;&#34;

                x, y = idxs
                if isinstance(x, slice) or isinstance(y, slice):
                        return self.values[x, y]
                else:
                        return self.interp_point(x,y)
                        



        def quickPlot(self, xlabel = None, ylabel = None, title = None, conversion = 1, clabel = None, cmap = &#39;viridis&#39;, saveto = None):

                &#34;&#34;&#34;
                Produce a quick plot of the lookup table

                Parameters
                ----------
                xlabel : str (Optional)
                        label for the x-axis
                ylabel : str (Optional)
                        label for the y-axis
                title : str (Optional)
                        title of the plot
                conversion : float (Optional, default 1)
                        a conversion factor for the plotted values. This method will plot X*conversion, Y*conversion
                clabel : str (Optional)
                        label of the color bar
                cmap : str      (Optional, default &#39;viridis&#39;)
                        the colormap to use (matplotlib colormaps)
                saveto : str (Optional, default None)
                        if not None: the path to save the plot to (the file extension defines the format)

                &#34;&#34;&#34;


                import matplotlib.pyplot as plt

                X, Y = np.meshgrid(self.linspace_x, self.linspace_y)
                fig, ax = plt.subplots()
                h = ax.contourf(X*conversion,Y*conversion, self.interp_point(self.linspace_x, self.linspace_y), cmap = cmap)
                c = plt.colorbar(h)
                c.set_label(clabel)
                ax.set_xlabel(xlabel)
                ax.set_ylabel(ylabel)
                ax.set_title(title)

                if saveto is not None:
                        plt.savefig(saveto, dpi = 800)

                plt.show()



class LookupTableND():
        def __init__(self, axes = None, values = None, info = None, np_array = None):
                self.axes = axes
                self.values = values
                self.info = info
                self.np_array = np_array


                self._set_defaults()


        def _set_defaults(self):
                self.interpType = &#39;linear&#39;

        def interpolator(self, vals):
                
                return interpolate.interpn(self.axes,self.values, vals, method = &#39;linear&#39;) 


        def set_interpType(self, interpType):
                self.interpType = interpType


        def get_idx(self, ind, search_list):
                return np.where(search_list == ind)[0][0]

        
        def interp_point(self, vals):
                return self.interpolator(vals)


        def __getitem__(self, idxs):
                &#34;&#34;&#34;
                Implement a getitem method.
                Several usages are possible:

                LUT[a,b]: if a, b are in the original lookup table, the original values are returned, otherwise they are interpolated
                LUT[:,:] or LUT[a:b, c:d]: return the original lut sliced as requested
                LUT[:,a]: return the original lut (all elements of first axis, integer-indexed elements of second axis)
                LUT[array-like, array-like]: return the lookup table interpolated in the array-like points

                &#34;&#34;&#34;

                
                if np.any([isinstance(x, slice) for x in idxs]) :
                        return self.values[idxs]
                else:
                        
                        outval =  self.interp_point(idxs)
                        return np.squeeze(outval)
                        

        def axisExtent(self):
                extent = []
                for ax in self.axes:
                        extent.append([np.min(ax), np.max(ax)])
                return extent


        def quickPlot(self, xlabel = None, ylabel = None, title = None, conversion = 1, clabel = None, cmap = &#39;viridis&#39;, saveto = None):
                import matplotlib.pyplot as plt

                X, Y = np.meshgrid(*self.axes)
                fig, ax = plt.subplots()
                h = ax.contourf(X*conversion,Y*conversion, self.interp_point(self.axes), cmap = cmap)
                c = plt.colorbar(h)
                c.set_label(clabel)
                ax.set_xlabel(xlabel)
                ax.set_ylabel(ylabel)
                ax.set_title(title)

                if saveto is not None:
                        plt.savefig(saveto, dpi = 800)

                plt.show()



class ScatterLookup():

        def __init__(self):
                self.zones = []
                self.zonedef = []

        def add_zone(self, ZoneLookup = &#39;&#39;):
                if not isinstance(ZoneLookup, LookupTableND):
                        raise TypeError(&#39;The ZoneLookup argument must be of type class.LookupTableND&#39;)

                self.zones.append(ZoneLookup)
                self.zonedef.append(ZoneLookup.axisExtent())

        def __getitem__(self, idxs):

                zone_no = self.zone_determination(idxs)
                return self.zones[zone_no][idxs]
                


        def zone_determination(self,idxs):
                flag = 1
                for i, zonedef in enumerate(self.zonedef):
                        #print(f&#39;Zone {zonedef}&#39;)  FOR DEBYG
                        for j, idx in enumerate(idxs):
                                if not zonedef[j][0]&lt;=idx&lt;=zonedef[j][1]:
                                        flag = 0
                                        print(idx, zonedef[j][0], zonedef[j][1])
                        if flag == 1:
                                return i 
                        elif i &lt; len(self.zonedef)-1:
                                flag = 1
                if flag == 0:
                        raise Exception(&#39;Interpolation Error: No data correspond to your request&#39;)




class TiffInterpolator():
        def __init__(self, axes = None, values = None):
                self.axes = axes
                self.values = values
                


                # Error control
                #if len(self.axes) != len(values.shape[0:-1]):
                #       raise ValueError(f&#39;The number of axes provided does not match with provided data\n Provided data has shape {len(values.shape)} while {len(self.axes)} axes have been provided&#39;)



                self._set_defaults()


        def _set_defaults(self):
                self.interpType = &#39;linear&#39;

        def interpolator(self, vals):
                
                return interpolate.interpn(self.axes,self.values.T, vals) 


        def set_interpType(self, interpType):
                self.interpType = interpType


        def get_idx(self, ind, search_list):
                return np.where(search_list == ind)[0][0]

        
        def interp_point(self, vals):
                return self.interpolator(vals)


        def __getitem__(self, idxs):
                &#34;&#34;&#34;
                Implement a getitem method.
                Several usages are possible:

                LUT[a,b]: if a, b are in the original lookup table, the original values are returned, otherwise they are interpolated
                LUT[:,:] or LUT[a:b, c:d]: return the original lut sliced as requested
                LUT[:,a]: return the original lut (all elements of first axis, integer-indexed elements of second axis)
                LUT[array-like, array-like]: return the lookup table interpolated in the array-like points

                &#34;&#34;&#34;

                
                if np.any([isinstance(x, slice) for x in idxs]) :
                        return self.values[idxs]
                else:
                        
                        outval =  self.interp_point(idxs)
                        return np.squeeze(outval)



def getSunAngles(scName = None, scFrame = None, epoch = None, correction = &#39;LT+S&#39;):
        sunPos = sp.spkezr(&#39;Sun&#39;, epoch, scFrame, correction, scName)[0][0:3]
        [_, ra, dec] = sp.recrad(sunPos)

        return ra, dec

        

def epochRange(startEpoch = None, duration = None, step = 100):
        if isinstance(startEpoch, str):
                startEp = sp.str2et(startEpoch)
        elif isinstance(startEpoch, float):
                startEp = startEpoch
        else:
                raise ValueError(&#39;startEpoch argument must be str or float&#39;)
        
        endEp = startEp + duration

        epochList = np.linspace(startEp, endEp, num = int(np.ceil((endEp - startEp)/step)), endpoint = False)
        return epochList


def epochRange2(startEpoch = None, endEpoch = None, step = 100):
        if isinstance(startEpoch, str):
                startEp = sp.str2et(startEpoch)
        elif isinstance(startEpoch, float):
                startEp = startEpoch
        else:
                raise ValueError(&#39;startEpoch argument must be str or float&#39;)


        if isinstance(endEpoch, str):
                endEp = sp.str2et(endEpoch)
        elif isinstance(endEpoch, float):
                endEp = endEpoch
        else:
                raise ValueError(&#39;endEpoch argument must be str or float&#39;)
        
        curr = startEp

        epochlist = []
        while curr &lt;= endEp:
                epochlist.append(curr)
                curr += step
        return np.array(epochlist)





def computeRADEC(vecs, periodicity = 360):
        &#34;&#34;&#34;
        From a ND array of shape (N, 3), compute RA/DEC

        Parameters:
        vecs: [ndarray (N,3)]
        Returns:
        RA, DEC
        &#34;&#34;&#34;

        n = block_normalize(vecs)
        dec = np.arcsin(n[:,2])
        sinB = n[:,1]/np.cos(dec)
        cosB = n[:,0]/np.cos(dec)
        ra = np.arctan2(sinB, cosB)

        if periodicity == 360:
                ra = np.where(ra &lt; 0, 2*np.pi + ra, ra)



        return ra, dec





def convertTIFtoMesh(tifFile = &#39;&#39;, latSampling = &#39;&#39;, inferSampling = False, lonSampling = &#39;&#39;, planet = &#39;&#39;, lat0 = -np.pi/2, lat1 = np.pi/2, lon0 = 0, lon1 = 2*np.pi):
        &#34;&#34;&#34;
        Convert a TIF map of emissivities to the format needed for assigning values to each face of a planetary 3D mesh

        Parameters:
        tifFile : [str] the path to the TIFF file
        latSampling: [float, in rad] sampling step of latitude
        lonSampling: [float, in rad] sampling step of longitude
        planet: [class.Planet] Planet object containing the mesh and the planetary frames
        inferSampling: [bool] wether the importer shall infer the sampling or not
        Returns:
        emissivityInterpolator: [class.LookupTableND] an interpolator for mapping the temperatures on the mesh faces. This is intended to be passed
                                to the Planet class via the setter method: Planet.emissivity = emissivityInterpolator

        &#34;&#34;&#34;


        im = Image.open(tifFile)
        
        #arr = np.expand_dims(np.array(im), axis = 2)
        arr = np.array(im)

        #import matplotlib.pyplot as plt
        #plt.figure()
        #print(np.array(im).shape)
        #plt.contourf(np.array(im))

        if inferSampling:
                lonSampling = (lon1-lon0)/arr.shape[1]
                latSampling = (lat1-lat0)/arr.shape[0]

        lats = np.linspace(lat0, lat1, int(ceil((lat1 - lat0) / latSampling )))
        lons = np.linspace(lon0, lon1, int(ceil((lon1 - lon0) / lonSampling )))

        lut = TiffInterpolator(axes = (lons, lats), values = arr)


        return lut




        &#39;&#39;&#39;
        newlats = np.linspace(lat0, lat1, 1000)
        newlons = np.linspace(lon0, lon1, 1000)
        import matplotlib.pyplot as plt
        plt.figure()
        plt.plot(lats,arr[0,:,0], marker = &#39;o&#39;, label = &#39;orig&#39;)
        dd = lut[0, newlats]
        plt.plot(newlats,dd, marker = &#39;.&#39;, label = &#39;interp&#39;)
        plt.legend()
        plt.show()
        &#39;&#39;&#39;



def convertEpoch(monteEpoch):
        &#39;&#39;&#39;
        Convert a Monte epoch string to a spice epoch string

        &#39;&#39;&#39;


def get_spacecraft_area(spacecraft, ra = 0.0, dec = 0.0, epoch = None):

        &#39;&#39;&#39;
        Compute a pyRTX.Spacecraft apparent area as seen by the direction specified 
        by a pair of right ascension - declination

        Input:
        spacecraft [pyRTX.Spacecraft]   : the spacecraft object
        ra [float]                                              : right ascension (in rad)
        dec [float]                                     : declination (rad)
        epoch [float or None]                   : epoch for the computation (this is used when moving Spice
                                                                                frames are used for the Spacecraft definition)

        Output:
        area [float]                                    : the apparent area. The measurement units depend on the units of the
                                                                                Spacecraft object

        TODO: avoid hardcoded width/height but rather use an automated method

        &#39;&#39;&#39;
        from pyRTX.pixelPlaneClass import pixelPlane
        from pyRTX.rayTracerClass import rayTracer
        rays = pixelPlane( 
                        spacecraft = spacecraft,   # Spacecraft object 
                        mode = &#39;Fixed&#39;,   # Mode: can be &#39;Dynamic&#39; ( The sun orientation is computed from the kernels), or &#39;Fixed&#39;
                        distance = 10000,           # Distance of the ray origin from the spacecraft
                        width = 100,        # Width of the pixel plane
                        height = 100,        # Height of the pixel plane
                        lon = ra,
                        lat = dec, 
                        ray_spacing = 0.1, # Ray spacing (in m)
                )

        rtx = rayTracer(        
                        spacecraft,                    # Spacecraft object
                        rays,                   # pixelPlane object
                        kernel = &#39;Embree&#39;,      # The RTX kernel to use
                        bounces = 1,            # The number of bounces to account for
                        diffusion = False,       # Account for secondary diffusion
                        ) 

        rtx.trace(epoch)
        hit_rays = rtx.index_ray_container
        Area =  len(hit_rays[0])/rays.norm_factor
        return Area</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyRTX.analysis_utils.computeRADEC"><code class="name flex">
<span>def <span class="ident">computeRADEC</span></span>(<span>vecs, periodicity=360)</span>
</code></dt>
<dd>
<div class="desc"><p>From a ND array of shape (N, 3), compute RA/DEC</p>
<p>Parameters:
vecs: [ndarray (N,3)]
Returns:
RA, DEC</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def computeRADEC(vecs, periodicity = 360):
        &#34;&#34;&#34;
        From a ND array of shape (N, 3), compute RA/DEC

        Parameters:
        vecs: [ndarray (N,3)]
        Returns:
        RA, DEC
        &#34;&#34;&#34;

        n = block_normalize(vecs)
        dec = np.arcsin(n[:,2])
        sinB = n[:,1]/np.cos(dec)
        cosB = n[:,0]/np.cos(dec)
        ra = np.arctan2(sinB, cosB)

        if periodicity == 360:
                ra = np.where(ra &lt; 0, 2*np.pi + ra, ra)



        return ra, dec</code></pre>
</details>
</dd>
<dt id="pyRTX.analysis_utils.convertEpoch"><code class="name flex">
<span>def <span class="ident">convertEpoch</span></span>(<span>monteEpoch)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a Monte epoch string to a spice epoch string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convertEpoch(monteEpoch):
        &#39;&#39;&#39;
        Convert a Monte epoch string to a spice epoch string

        &#39;&#39;&#39;</code></pre>
</details>
</dd>
<dt id="pyRTX.analysis_utils.convertTIFtoMesh"><code class="name flex">
<span>def <span class="ident">convertTIFtoMesh</span></span>(<span>tifFile='', latSampling='', inferSampling=False, lonSampling='', planet='', lat0=-1.5707963267948966, lat1=1.5707963267948966, lon0=0, lon1=6.283185307179586)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a TIF map of emissivities to the format needed for assigning values to each face of a planetary 3D mesh</p>
<p>Parameters:
tifFile : [str] the path to the TIFF file
latSampling: [float, in rad] sampling step of latitude
lonSampling: [float, in rad] sampling step of longitude
planet: [class.Planet] Planet object containing the mesh and the planetary frames
inferSampling: [bool] wether the importer shall infer the sampling or not
Returns:
emissivityInterpolator: [class.LookupTableND] an interpolator for mapping the temperatures on the mesh faces. This is intended to be passed
to the Planet class via the setter method: Planet.emissivity = emissivityInterpolator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convertTIFtoMesh(tifFile = &#39;&#39;, latSampling = &#39;&#39;, inferSampling = False, lonSampling = &#39;&#39;, planet = &#39;&#39;, lat0 = -np.pi/2, lat1 = np.pi/2, lon0 = 0, lon1 = 2*np.pi):
        &#34;&#34;&#34;
        Convert a TIF map of emissivities to the format needed for assigning values to each face of a planetary 3D mesh

        Parameters:
        tifFile : [str] the path to the TIFF file
        latSampling: [float, in rad] sampling step of latitude
        lonSampling: [float, in rad] sampling step of longitude
        planet: [class.Planet] Planet object containing the mesh and the planetary frames
        inferSampling: [bool] wether the importer shall infer the sampling or not
        Returns:
        emissivityInterpolator: [class.LookupTableND] an interpolator for mapping the temperatures on the mesh faces. This is intended to be passed
                                to the Planet class via the setter method: Planet.emissivity = emissivityInterpolator

        &#34;&#34;&#34;


        im = Image.open(tifFile)
        
        #arr = np.expand_dims(np.array(im), axis = 2)
        arr = np.array(im)

        #import matplotlib.pyplot as plt
        #plt.figure()
        #print(np.array(im).shape)
        #plt.contourf(np.array(im))

        if inferSampling:
                lonSampling = (lon1-lon0)/arr.shape[1]
                latSampling = (lat1-lat0)/arr.shape[0]

        lats = np.linspace(lat0, lat1, int(ceil((lat1 - lat0) / latSampling )))
        lons = np.linspace(lon0, lon1, int(ceil((lon1 - lon0) / lonSampling )))

        lut = TiffInterpolator(axes = (lons, lats), values = arr)


        return lut




        &#39;&#39;&#39;
        newlats = np.linspace(lat0, lat1, 1000)
        newlons = np.linspace(lon0, lon1, 1000)
        import matplotlib.pyplot as plt
        plt.figure()
        plt.plot(lats,arr[0,:,0], marker = &#39;o&#39;, label = &#39;orig&#39;)
        dd = lut[0, newlats]
        plt.plot(newlats,dd, marker = &#39;.&#39;, label = &#39;interp&#39;)
        plt.legend()
        plt.show()
        &#39;&#39;&#39;</code></pre>
</details>
</dd>
<dt id="pyRTX.analysis_utils.epochRange"><code class="name flex">
<span>def <span class="ident">epochRange</span></span>(<span>startEpoch=None, duration=None, step=100)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def epochRange(startEpoch = None, duration = None, step = 100):
        if isinstance(startEpoch, str):
                startEp = sp.str2et(startEpoch)
        elif isinstance(startEpoch, float):
                startEp = startEpoch
        else:
                raise ValueError(&#39;startEpoch argument must be str or float&#39;)
        
        endEp = startEp + duration

        epochList = np.linspace(startEp, endEp, num = int(np.ceil((endEp - startEp)/step)), endpoint = False)
        return epochList</code></pre>
</details>
</dd>
<dt id="pyRTX.analysis_utils.epochRange2"><code class="name flex">
<span>def <span class="ident">epochRange2</span></span>(<span>startEpoch=None, endEpoch=None, step=100)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def epochRange2(startEpoch = None, endEpoch = None, step = 100):
        if isinstance(startEpoch, str):
                startEp = sp.str2et(startEpoch)
        elif isinstance(startEpoch, float):
                startEp = startEpoch
        else:
                raise ValueError(&#39;startEpoch argument must be str or float&#39;)


        if isinstance(endEpoch, str):
                endEp = sp.str2et(endEpoch)
        elif isinstance(endEpoch, float):
                endEp = endEpoch
        else:
                raise ValueError(&#39;endEpoch argument must be str or float&#39;)
        
        curr = startEp

        epochlist = []
        while curr &lt;= endEp:
                epochlist.append(curr)
                curr += step
        return np.array(epochlist)</code></pre>
</details>
</dd>
<dt id="pyRTX.analysis_utils.getSunAngles"><code class="name flex">
<span>def <span class="ident">getSunAngles</span></span>(<span>scName=None, scFrame=None, epoch=None, correction='LT+S')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSunAngles(scName = None, scFrame = None, epoch = None, correction = &#39;LT+S&#39;):
        sunPos = sp.spkezr(&#39;Sun&#39;, epoch, scFrame, correction, scName)[0][0:3]
        [_, ra, dec] = sp.recrad(sunPos)

        return ra, dec</code></pre>
</details>
</dd>
<dt id="pyRTX.analysis_utils.get_spacecraft_area"><code class="name flex">
<span>def <span class="ident">get_spacecraft_area</span></span>(<span>spacecraft, ra=0.0, dec=0.0, epoch=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute a pyRTX.Spacecraft apparent area as seen by the direction specified
by a pair of right ascension - declination</p>
<p>Input:
spacecraft [pyRTX.Spacecraft]
: the spacecraft object
ra [float]
: right ascension (in rad)
dec [float]
: declination (rad)
epoch [float or None]
: epoch for the computation (this is used when moving Spice
frames are used for the Spacecraft definition)</p>
<p>Output:
area [float]
: the apparent area. The measurement units depend on the units of the
Spacecraft object</p>
<p>TODO: avoid hardcoded width/height but rather use an automated method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_spacecraft_area(spacecraft, ra = 0.0, dec = 0.0, epoch = None):

        &#39;&#39;&#39;
        Compute a pyRTX.Spacecraft apparent area as seen by the direction specified 
        by a pair of right ascension - declination

        Input:
        spacecraft [pyRTX.Spacecraft]   : the spacecraft object
        ra [float]                                              : right ascension (in rad)
        dec [float]                                     : declination (rad)
        epoch [float or None]                   : epoch for the computation (this is used when moving Spice
                                                                                frames are used for the Spacecraft definition)

        Output:
        area [float]                                    : the apparent area. The measurement units depend on the units of the
                                                                                Spacecraft object

        TODO: avoid hardcoded width/height but rather use an automated method

        &#39;&#39;&#39;
        from pyRTX.pixelPlaneClass import pixelPlane
        from pyRTX.rayTracerClass import rayTracer
        rays = pixelPlane( 
                        spacecraft = spacecraft,   # Spacecraft object 
                        mode = &#39;Fixed&#39;,   # Mode: can be &#39;Dynamic&#39; ( The sun orientation is computed from the kernels), or &#39;Fixed&#39;
                        distance = 10000,           # Distance of the ray origin from the spacecraft
                        width = 100,        # Width of the pixel plane
                        height = 100,        # Height of the pixel plane
                        lon = ra,
                        lat = dec, 
                        ray_spacing = 0.1, # Ray spacing (in m)
                )

        rtx = rayTracer(        
                        spacecraft,                    # Spacecraft object
                        rays,                   # pixelPlane object
                        kernel = &#39;Embree&#39;,      # The RTX kernel to use
                        bounces = 1,            # The number of bounces to account for
                        diffusion = False,       # Account for secondary diffusion
                        ) 

        rtx.trace(epoch)
        hit_rays = rtx.index_ray_container
        Area =  len(hit_rays[0])/rays.norm_factor
        return Area</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyRTX.analysis_utils.LookupTable"><code class="flex name class">
<span>class <span class="ident">LookupTable</span></span>
<span>(</span><span>linspace_x, linspace_y, values)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to store results in the shape aof a lookup table.
This is mainly used to store the resultas of a set of raytracing results
example: the solar pressure for a body is computed for a grid of RA/DEC values.
these values can be stored in the LookupTable object and later retrieved.
This class offers the possibility of not oly retrieving pre-computed values, but
aslso interpolating between grid points.</p>
<p>NOTE: the grid of the lookup table does not need to be regular
the interpolation is based on numpy griddata method which is able to cope
with unstructured grids</p>
<p>The main way of retrieving values is through indexing. The following are implemented:</p>
<p>LUT[a,b]: if a, b are in the original lookup table, the original values are returned, otherwise they are interpolated
LUT[:,:] or LUT[a:b, c:d]: return the original lut sliced as requested
LUT[:,a]: return the original lut (all elements of first axis, integer-indexed elements of second axis)
LUT[array-like, array-like]: return the lookup table interpolated in the array-like points</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>linspace_x</code></strong> :&ensp;<code>np.array(N,)</code></dt>
<dd>The x axis of the lookup table</dd>
<dt><strong><code>linspace_y</code></strong> :&ensp;<code>np.array(M,)</code></dt>
<dd>The y axis of the lookup table</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>np.ndarray (N,M,1)</code></dt>
<dd>The lookup table values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LookupTable():
        &#34;&#34;&#34;
        This class is used to store results in the shape aof a lookup table.
        This is mainly used to store the resultas of a set of raytracing results
        example: the solar pressure for a body is computed for a grid of RA/DEC values.
        these values can be stored in the LookupTable object and later retrieved.
        This class offers the possibility of not oly retrieving pre-computed values, but
        aslso interpolating between grid points.

        NOTE: the grid of the lookup table does not need to be regular
        the interpolation is based on numpy griddata method which is able to cope
        with unstructured grids

        The main way of retrieving values is through indexing. The following are implemented:

        LUT[a,b]: if a, b are in the original lookup table, the original values are returned, otherwise they are interpolated
        LUT[:,:] or LUT[a:b, c:d]: return the original lut sliced as requested
        LUT[:,a]: return the original lut (all elements of first axis, integer-indexed elements of second axis)
        LUT[array-like, array-like]: return the lookup table interpolated in the array-like points



        Parameters
        ----------
        linspace_x : np.array(N,)
                The x axis of the lookup table
        linspace_y : np.array(M,)
                The y axis of the lookup table
        values : np.ndarray (N,M,1)
                The lookup table values


        &#34;&#34;&#34;
        def __init__(self, linspace_x, linspace_y, values):
                self.linspace_x = linspace_x
                self.linspace_y = linspace_y
                self.values = values

                self._set_defaults()


        def _set_defaults(self):
                self.interpType = &#39;cubic&#39;

        def _interpolator(self, x, y):

                x, y = np.meshgrid(x,y)
                meshgrid_x, meshgrid_y = np.meshgrid(self.linspace_x, self.linspace_y)
                #return  interpolate.griddata((meshgrid_x.ravel(), meshgrid_y.ravel()), self.values.T.ravel(),np.array([x,y]).T, method = self.interpType)
                return  interpolate.griddata((meshgrid_x.ravel(), meshgrid_y.ravel()), self.values.T.ravel(),(x,y), method = self.interpType)

        def set_interpType(self, interpType):
                self.interpType = interpType


        def _get_idx(self, ind, search_list):
                return np.where(search_list == ind)[0][0]

        
        def interp_point(self, x, y):
                return self._interpolator(x,y)


        def __getitem__(self, idxs):
                &#34;&#34;&#34;
                Implement a getitem method.
                Several usages are possible:

                LUT[a,b]: if a, b are in the original lookup table, the original values are returned, otherwise they are interpolated
                LUT[:,:] or LUT[a:b, c:d]: return the original lut sliced as requested
                LUT[:,a]: return the original lut (all elements of first axis, integer-indexed elements of second axis)
                LUT[array-like, array-like]: return the lookup table interpolated in the array-like points

                &#34;&#34;&#34;

                x, y = idxs
                if isinstance(x, slice) or isinstance(y, slice):
                        return self.values[x, y]
                else:
                        return self.interp_point(x,y)
                        



        def quickPlot(self, xlabel = None, ylabel = None, title = None, conversion = 1, clabel = None, cmap = &#39;viridis&#39;, saveto = None):

                &#34;&#34;&#34;
                Produce a quick plot of the lookup table

                Parameters
                ----------
                xlabel : str (Optional)
                        label for the x-axis
                ylabel : str (Optional)
                        label for the y-axis
                title : str (Optional)
                        title of the plot
                conversion : float (Optional, default 1)
                        a conversion factor for the plotted values. This method will plot X*conversion, Y*conversion
                clabel : str (Optional)
                        label of the color bar
                cmap : str      (Optional, default &#39;viridis&#39;)
                        the colormap to use (matplotlib colormaps)
                saveto : str (Optional, default None)
                        if not None: the path to save the plot to (the file extension defines the format)

                &#34;&#34;&#34;


                import matplotlib.pyplot as plt

                X, Y = np.meshgrid(self.linspace_x, self.linspace_y)
                fig, ax = plt.subplots()
                h = ax.contourf(X*conversion,Y*conversion, self.interp_point(self.linspace_x, self.linspace_y), cmap = cmap)
                c = plt.colorbar(h)
                c.set_label(clabel)
                ax.set_xlabel(xlabel)
                ax.set_ylabel(ylabel)
                ax.set_title(title)

                if saveto is not None:
                        plt.savefig(saveto, dpi = 800)

                plt.show()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyRTX.analysis_utils.LookupTable.interp_point"><code class="name flex">
<span>def <span class="ident">interp_point</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interp_point(self, x, y):
        return self._interpolator(x,y)</code></pre>
</details>
</dd>
<dt id="pyRTX.analysis_utils.LookupTable.quickPlot"><code class="name flex">
<span>def <span class="ident">quickPlot</span></span>(<span>self, xlabel=None, ylabel=None, title=None, conversion=1, clabel=None, cmap='viridis', saveto=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce a quick plot of the lookup table</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xlabel</code></strong> :&ensp;<code>str (Optional)</code></dt>
<dd>label for the x-axis</dd>
<dt><strong><code>ylabel</code></strong> :&ensp;<code>str (Optional)</code></dt>
<dd>label for the y-axis</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str (Optional)</code></dt>
<dd>title of the plot</dd>
<dt><strong><code>conversion</code></strong> :&ensp;<code>float (Optional</code>, default <code>1)</code></dt>
<dd>a conversion factor for the plotted values. This method will plot X<em>conversion, Y</em>conversion</dd>
<dt><strong><code>clabel</code></strong> :&ensp;<code>str (Optional)</code></dt>
<dd>label of the color bar</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str
(Optional</code>, default <code>'viridis')</code></dt>
<dd>the colormap to use (matplotlib colormaps)</dd>
<dt><strong><code>saveto</code></strong> :&ensp;<code>str (Optional</code>, default <code>None)</code></dt>
<dd>if not None: the path to save the plot to (the file extension defines the format)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quickPlot(self, xlabel = None, ylabel = None, title = None, conversion = 1, clabel = None, cmap = &#39;viridis&#39;, saveto = None):

        &#34;&#34;&#34;
        Produce a quick plot of the lookup table

        Parameters
        ----------
        xlabel : str (Optional)
                label for the x-axis
        ylabel : str (Optional)
                label for the y-axis
        title : str (Optional)
                title of the plot
        conversion : float (Optional, default 1)
                a conversion factor for the plotted values. This method will plot X*conversion, Y*conversion
        clabel : str (Optional)
                label of the color bar
        cmap : str      (Optional, default &#39;viridis&#39;)
                the colormap to use (matplotlib colormaps)
        saveto : str (Optional, default None)
                if not None: the path to save the plot to (the file extension defines the format)

        &#34;&#34;&#34;


        import matplotlib.pyplot as plt

        X, Y = np.meshgrid(self.linspace_x, self.linspace_y)
        fig, ax = plt.subplots()
        h = ax.contourf(X*conversion,Y*conversion, self.interp_point(self.linspace_x, self.linspace_y), cmap = cmap)
        c = plt.colorbar(h)
        c.set_label(clabel)
        ax.set_xlabel(xlabel)
        ax.set_ylabel(ylabel)
        ax.set_title(title)

        if saveto is not None:
                plt.savefig(saveto, dpi = 800)

        plt.show()</code></pre>
</details>
</dd>
<dt id="pyRTX.analysis_utils.LookupTable.set_interpType"><code class="name flex">
<span>def <span class="ident">set_interpType</span></span>(<span>self, interpType)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_interpType(self, interpType):
        self.interpType = interpType</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyRTX.analysis_utils.LookupTableND"><code class="flex name class">
<span>class <span class="ident">LookupTableND</span></span>
<span>(</span><span>axes=None, values=None, info=None, np_array=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LookupTableND():
        def __init__(self, axes = None, values = None, info = None, np_array = None):
                self.axes = axes
                self.values = values
                self.info = info
                self.np_array = np_array


                self._set_defaults()


        def _set_defaults(self):
                self.interpType = &#39;linear&#39;

        def interpolator(self, vals):
                
                return interpolate.interpn(self.axes,self.values, vals, method = &#39;linear&#39;) 


        def set_interpType(self, interpType):
                self.interpType = interpType


        def get_idx(self, ind, search_list):
                return np.where(search_list == ind)[0][0]

        
        def interp_point(self, vals):
                return self.interpolator(vals)


        def __getitem__(self, idxs):
                &#34;&#34;&#34;
                Implement a getitem method.
                Several usages are possible:

                LUT[a,b]: if a, b are in the original lookup table, the original values are returned, otherwise they are interpolated
                LUT[:,:] or LUT[a:b, c:d]: return the original lut sliced as requested
                LUT[:,a]: return the original lut (all elements of first axis, integer-indexed elements of second axis)
                LUT[array-like, array-like]: return the lookup table interpolated in the array-like points

                &#34;&#34;&#34;

                
                if np.any([isinstance(x, slice) for x in idxs]) :
                        return self.values[idxs]
                else:
                        
                        outval =  self.interp_point(idxs)
                        return np.squeeze(outval)
                        

        def axisExtent(self):
                extent = []
                for ax in self.axes:
                        extent.append([np.min(ax), np.max(ax)])
                return extent


        def quickPlot(self, xlabel = None, ylabel = None, title = None, conversion = 1, clabel = None, cmap = &#39;viridis&#39;, saveto = None):
                import matplotlib.pyplot as plt

                X, Y = np.meshgrid(*self.axes)
                fig, ax = plt.subplots()
                h = ax.contourf(X*conversion,Y*conversion, self.interp_point(self.axes), cmap = cmap)
                c = plt.colorbar(h)
                c.set_label(clabel)
                ax.set_xlabel(xlabel)
                ax.set_ylabel(ylabel)
                ax.set_title(title)

                if saveto is not None:
                        plt.savefig(saveto, dpi = 800)

                plt.show()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyRTX.analysis_utils.LookupTableND.axisExtent"><code class="name flex">
<span>def <span class="ident">axisExtent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def axisExtent(self):
        extent = []
        for ax in self.axes:
                extent.append([np.min(ax), np.max(ax)])
        return extent</code></pre>
</details>
</dd>
<dt id="pyRTX.analysis_utils.LookupTableND.get_idx"><code class="name flex">
<span>def <span class="ident">get_idx</span></span>(<span>self, ind, search_list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_idx(self, ind, search_list):
        return np.where(search_list == ind)[0][0]</code></pre>
</details>
</dd>
<dt id="pyRTX.analysis_utils.LookupTableND.interp_point"><code class="name flex">
<span>def <span class="ident">interp_point</span></span>(<span>self, vals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interp_point(self, vals):
        return self.interpolator(vals)</code></pre>
</details>
</dd>
<dt id="pyRTX.analysis_utils.LookupTableND.interpolator"><code class="name flex">
<span>def <span class="ident">interpolator</span></span>(<span>self, vals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolator(self, vals):
        
        return interpolate.interpn(self.axes,self.values, vals, method = &#39;linear&#39;) </code></pre>
</details>
</dd>
<dt id="pyRTX.analysis_utils.LookupTableND.quickPlot"><code class="name flex">
<span>def <span class="ident">quickPlot</span></span>(<span>self, xlabel=None, ylabel=None, title=None, conversion=1, clabel=None, cmap='viridis', saveto=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quickPlot(self, xlabel = None, ylabel = None, title = None, conversion = 1, clabel = None, cmap = &#39;viridis&#39;, saveto = None):
        import matplotlib.pyplot as plt

        X, Y = np.meshgrid(*self.axes)
        fig, ax = plt.subplots()
        h = ax.contourf(X*conversion,Y*conversion, self.interp_point(self.axes), cmap = cmap)
        c = plt.colorbar(h)
        c.set_label(clabel)
        ax.set_xlabel(xlabel)
        ax.set_ylabel(ylabel)
        ax.set_title(title)

        if saveto is not None:
                plt.savefig(saveto, dpi = 800)

        plt.show()</code></pre>
</details>
</dd>
<dt id="pyRTX.analysis_utils.LookupTableND.set_interpType"><code class="name flex">
<span>def <span class="ident">set_interpType</span></span>(<span>self, interpType)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_interpType(self, interpType):
        self.interpType = interpType</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyRTX.analysis_utils.ScatterLookup"><code class="flex name class">
<span>class <span class="ident">ScatterLookup</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScatterLookup():

        def __init__(self):
                self.zones = []
                self.zonedef = []

        def add_zone(self, ZoneLookup = &#39;&#39;):
                if not isinstance(ZoneLookup, LookupTableND):
                        raise TypeError(&#39;The ZoneLookup argument must be of type class.LookupTableND&#39;)

                self.zones.append(ZoneLookup)
                self.zonedef.append(ZoneLookup.axisExtent())

        def __getitem__(self, idxs):

                zone_no = self.zone_determination(idxs)
                return self.zones[zone_no][idxs]
                


        def zone_determination(self,idxs):
                flag = 1
                for i, zonedef in enumerate(self.zonedef):
                        #print(f&#39;Zone {zonedef}&#39;)  FOR DEBYG
                        for j, idx in enumerate(idxs):
                                if not zonedef[j][0]&lt;=idx&lt;=zonedef[j][1]:
                                        flag = 0
                                        print(idx, zonedef[j][0], zonedef[j][1])
                        if flag == 1:
                                return i 
                        elif i &lt; len(self.zonedef)-1:
                                flag = 1
                if flag == 0:
                        raise Exception(&#39;Interpolation Error: No data correspond to your request&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyRTX.analysis_utils.ScatterLookup.add_zone"><code class="name flex">
<span>def <span class="ident">add_zone</span></span>(<span>self, ZoneLookup='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_zone(self, ZoneLookup = &#39;&#39;):
        if not isinstance(ZoneLookup, LookupTableND):
                raise TypeError(&#39;The ZoneLookup argument must be of type class.LookupTableND&#39;)

        self.zones.append(ZoneLookup)
        self.zonedef.append(ZoneLookup.axisExtent())</code></pre>
</details>
</dd>
<dt id="pyRTX.analysis_utils.ScatterLookup.zone_determination"><code class="name flex">
<span>def <span class="ident">zone_determination</span></span>(<span>self, idxs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zone_determination(self,idxs):
        flag = 1
        for i, zonedef in enumerate(self.zonedef):
                #print(f&#39;Zone {zonedef}&#39;)  FOR DEBYG
                for j, idx in enumerate(idxs):
                        if not zonedef[j][0]&lt;=idx&lt;=zonedef[j][1]:
                                flag = 0
                                print(idx, zonedef[j][0], zonedef[j][1])
                if flag == 1:
                        return i 
                elif i &lt; len(self.zonedef)-1:
                        flag = 1
        if flag == 0:
                raise Exception(&#39;Interpolation Error: No data correspond to your request&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyRTX.analysis_utils.TiffInterpolator"><code class="flex name class">
<span>class <span class="ident">TiffInterpolator</span></span>
<span>(</span><span>axes=None, values=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TiffInterpolator():
        def __init__(self, axes = None, values = None):
                self.axes = axes
                self.values = values
                


                # Error control
                #if len(self.axes) != len(values.shape[0:-1]):
                #       raise ValueError(f&#39;The number of axes provided does not match with provided data\n Provided data has shape {len(values.shape)} while {len(self.axes)} axes have been provided&#39;)



                self._set_defaults()


        def _set_defaults(self):
                self.interpType = &#39;linear&#39;

        def interpolator(self, vals):
                
                return interpolate.interpn(self.axes,self.values.T, vals) 


        def set_interpType(self, interpType):
                self.interpType = interpType


        def get_idx(self, ind, search_list):
                return np.where(search_list == ind)[0][0]

        
        def interp_point(self, vals):
                return self.interpolator(vals)


        def __getitem__(self, idxs):
                &#34;&#34;&#34;
                Implement a getitem method.
                Several usages are possible:

                LUT[a,b]: if a, b are in the original lookup table, the original values are returned, otherwise they are interpolated
                LUT[:,:] or LUT[a:b, c:d]: return the original lut sliced as requested
                LUT[:,a]: return the original lut (all elements of first axis, integer-indexed elements of second axis)
                LUT[array-like, array-like]: return the lookup table interpolated in the array-like points

                &#34;&#34;&#34;

                
                if np.any([isinstance(x, slice) for x in idxs]) :
                        return self.values[idxs]
                else:
                        
                        outval =  self.interp_point(idxs)
                        return np.squeeze(outval)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyRTX.analysis_utils.TiffInterpolator.get_idx"><code class="name flex">
<span>def <span class="ident">get_idx</span></span>(<span>self, ind, search_list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_idx(self, ind, search_list):
        return np.where(search_list == ind)[0][0]</code></pre>
</details>
</dd>
<dt id="pyRTX.analysis_utils.TiffInterpolator.interp_point"><code class="name flex">
<span>def <span class="ident">interp_point</span></span>(<span>self, vals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interp_point(self, vals):
        return self.interpolator(vals)</code></pre>
</details>
</dd>
<dt id="pyRTX.analysis_utils.TiffInterpolator.interpolator"><code class="name flex">
<span>def <span class="ident">interpolator</span></span>(<span>self, vals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolator(self, vals):
        
        return interpolate.interpn(self.axes,self.values.T, vals) </code></pre>
</details>
</dd>
<dt id="pyRTX.analysis_utils.TiffInterpolator.set_interpType"><code class="name flex">
<span>def <span class="ident">set_interpType</span></span>(<span>self, interpType)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_interpType(self, interpType):
        self.interpType = interpType</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyRTX" href="index.html">pyRTX</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="pyRTX.analysis_utils.computeRADEC" href="#pyRTX.analysis_utils.computeRADEC">computeRADEC</a></code></li>
<li><code><a title="pyRTX.analysis_utils.convertEpoch" href="#pyRTX.analysis_utils.convertEpoch">convertEpoch</a></code></li>
<li><code><a title="pyRTX.analysis_utils.convertTIFtoMesh" href="#pyRTX.analysis_utils.convertTIFtoMesh">convertTIFtoMesh</a></code></li>
<li><code><a title="pyRTX.analysis_utils.epochRange" href="#pyRTX.analysis_utils.epochRange">epochRange</a></code></li>
<li><code><a title="pyRTX.analysis_utils.epochRange2" href="#pyRTX.analysis_utils.epochRange2">epochRange2</a></code></li>
<li><code><a title="pyRTX.analysis_utils.getSunAngles" href="#pyRTX.analysis_utils.getSunAngles">getSunAngles</a></code></li>
<li><code><a title="pyRTX.analysis_utils.get_spacecraft_area" href="#pyRTX.analysis_utils.get_spacecraft_area">get_spacecraft_area</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyRTX.analysis_utils.LookupTable" href="#pyRTX.analysis_utils.LookupTable">LookupTable</a></code></h4>
<ul class="">
<li><code><a title="pyRTX.analysis_utils.LookupTable.interp_point" href="#pyRTX.analysis_utils.LookupTable.interp_point">interp_point</a></code></li>
<li><code><a title="pyRTX.analysis_utils.LookupTable.quickPlot" href="#pyRTX.analysis_utils.LookupTable.quickPlot">quickPlot</a></code></li>
<li><code><a title="pyRTX.analysis_utils.LookupTable.set_interpType" href="#pyRTX.analysis_utils.LookupTable.set_interpType">set_interpType</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyRTX.analysis_utils.LookupTableND" href="#pyRTX.analysis_utils.LookupTableND">LookupTableND</a></code></h4>
<ul class="two-column">
<li><code><a title="pyRTX.analysis_utils.LookupTableND.axisExtent" href="#pyRTX.analysis_utils.LookupTableND.axisExtent">axisExtent</a></code></li>
<li><code><a title="pyRTX.analysis_utils.LookupTableND.get_idx" href="#pyRTX.analysis_utils.LookupTableND.get_idx">get_idx</a></code></li>
<li><code><a title="pyRTX.analysis_utils.LookupTableND.interp_point" href="#pyRTX.analysis_utils.LookupTableND.interp_point">interp_point</a></code></li>
<li><code><a title="pyRTX.analysis_utils.LookupTableND.interpolator" href="#pyRTX.analysis_utils.LookupTableND.interpolator">interpolator</a></code></li>
<li><code><a title="pyRTX.analysis_utils.LookupTableND.quickPlot" href="#pyRTX.analysis_utils.LookupTableND.quickPlot">quickPlot</a></code></li>
<li><code><a title="pyRTX.analysis_utils.LookupTableND.set_interpType" href="#pyRTX.analysis_utils.LookupTableND.set_interpType">set_interpType</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyRTX.analysis_utils.ScatterLookup" href="#pyRTX.analysis_utils.ScatterLookup">ScatterLookup</a></code></h4>
<ul class="">
<li><code><a title="pyRTX.analysis_utils.ScatterLookup.add_zone" href="#pyRTX.analysis_utils.ScatterLookup.add_zone">add_zone</a></code></li>
<li><code><a title="pyRTX.analysis_utils.ScatterLookup.zone_determination" href="#pyRTX.analysis_utils.ScatterLookup.zone_determination">zone_determination</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyRTX.analysis_utils.TiffInterpolator" href="#pyRTX.analysis_utils.TiffInterpolator">TiffInterpolator</a></code></h4>
<ul class="">
<li><code><a title="pyRTX.analysis_utils.TiffInterpolator.get_idx" href="#pyRTX.analysis_utils.TiffInterpolator.get_idx">get_idx</a></code></li>
<li><code><a title="pyRTX.analysis_utils.TiffInterpolator.interp_point" href="#pyRTX.analysis_utils.TiffInterpolator.interp_point">interp_point</a></code></li>
<li><code><a title="pyRTX.analysis_utils.TiffInterpolator.interpolator" href="#pyRTX.analysis_utils.TiffInterpolator.interpolator">interpolator</a></code></li>
<li><code><a title="pyRTX.analysis_utils.TiffInterpolator.set_interpType" href="#pyRTX.analysis_utils.TiffInterpolator.set_interpType">set_interpType</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>